% Natural Deduction - FOL Extended with Lists and Recursion

%% Types of individuals 
i : type.  % Type of individuals for FOL

%% Define constants to use in examples
LF elt : type =  % Type for specific elements
  | a : elt   % constant a
  | b : elt;  % constant b

%% List type - our primary inductive data structure
%% We'll use this to represent both lists and natural numbers (as lists of length n)
LF list : type = 
  | nil : list  % Empty list (also represents zero)
  | cons : elt -> list -> list ; % Cons cell (adding one element also represents successor)

%% Formulas of logic
LF o : type = 
  | ⊃ : o -> o -> o
  | ⊤ : o
  | ∧ : o -> o -> o
  | ∨ : o -> o -> o
  | ¬ : o -> o
  | ∀ : (i -> o) -> o
  | ∃ : (i -> o) -> o
  | eqList : list -> list -> o  % Equality for lists
  | appendR : list -> list -> list -> o  % Embedding of append relation
  | lengthR : list -> list -> o ;  % Length relation (second arg is a list representing the length)

--prefix ¬ 10.
--infix ∧ 6 right.
--infix ∨ 5 right.
--infix ⊃ 4 right.
--prefix ∀ 8.
--prefix ∃ 8.

%% Natural Deduction rules for relation embeddings
LF nd : o -> type =
  | ⊃I : (nd A -> nd B) -> nd (A ⊃ B)
  | ⊃E : nd (A ⊃ B) -> nd A -> nd B
  | ¬I : ({p:o} nd A -> nd p) -> nd (¬ A)
  | ¬E : nd (¬ A) -> nd A -> nd C
  | ∧I : nd A -> nd B -> nd (A ∧ B)
  | ∧El : nd (A ∧ B) -> nd A
  | ∧Er : nd (A ∧ B) -> nd B
  | ∨Il : nd A -> nd (A ∨ B)
  | ∨Ir : nd B -> nd (A ∨ B)
  | ∨E : nd (A ∨ B) -> (nd A -> nd C) -> (nd B -> nd C) -> nd C
  | ⊤I : nd ⊤
  | ∀I : ({a:i} nd (A a)) -> nd (∀ (\x. A x))
  | ∀E : {T:i} nd (∀ A) -> nd (A T)
  | ∃I : {T:i} nd (A T) -> nd (∃ A)
  | ∃E : nd (∃ A) -> ({a:i} nd (A a) -> nd C) -> nd C

  % List equality rules
  | eqList_refl : {l:list} nd (eqList l l)
  | eqList_sym : nd (eqList L1 L2) -> nd (eqList L2 L1)
  | eqList_trans : nd (eqList L1 L2) -> nd (eqList L2 L3) -> nd (eqList L1 L3)
  | eqList_nil : nd (eqList nil nil)
  | eqList_cons : {x:elt}{y:elt} nd (eqList L1 L2) -> nd (eqList (cons x L1) (cons y L2))
  
  % Relation embedding rules for lists  
  | lengthR_nil : nd (lengthR nil nil)  % Empty list has length 0 (represented by empty list)
  | lengthR_cons : {x:elt}{xs:list}{n:list} 
                  nd (lengthR xs n) -> nd (lengthR (cons x xs) (cons x n))
  
  | appendR_nil : {ys:list} nd (appendR nil ys ys)
  | appendR_cons : {x:elt}{xs:list}{ys:list}{zs:list} 
                  nd (appendR xs ys zs) -> nd (appendR (cons x xs) ys (cons x zs)) ;

% Simple specific cases - list operations

% Appending nil with nil gives nil
rec append_nil_nil : [⊢ nd (appendR nil nil nil)] =
  [⊢ appendR_nil nil];
  
% Appending nil with [a] gives [a]
rec append_nil_cons_example : [⊢ nd (appendR nil (cons a nil) (cons a nil))] =
  [⊢ appendR_nil (cons a nil)];
  
% Length of empty list is empty list (representing zero)
rec length_nil_proof : [⊢ nd (lengthR nil nil)] =
  [⊢ lengthR_nil];

% Length of a singleton list is a singleton list (representing one)
rec length_one_example : [⊢ nd (lengthR (cons a nil) (cons a nil))] =
  [⊢ lengthR_cons a nil nil lengthR_nil];

% Addition as composition of append and length
% For two lists l1 and l2, the "sum" of their lengths would be lengthR(append(l1, l2))
rec add_as_append_example : [⊢ nd (appendR (cons a nil) (cons b nil) (cons a (cons b nil)))] =
  [⊢ appendR_cons a nil (cons b nil) (cons b nil) (appendR_nil (cons b nil))];

% Length of append theorem - specific case for [a] and [b]  
rec length_append_example : [⊢ nd (lengthR (cons a (cons b nil)) (cons a (cons b nil)))] =
  [⊢ lengthR_cons a (cons b nil) (cons b nil) (lengthR_cons b nil nil lengthR_nil)];

% Base case: length(append(nil, l)) = length(l)
rec length_append_base_specific : [⊢ nd (lengthR (cons a nil) (cons a nil))] =
  [⊢ lengthR_cons a nil nil lengthR_nil];

% Theorem: append(l, nil) = l (specific example)
rec append_nil_identity_example : [⊢ nd (eqList (cons a nil) (cons a nil))] =
  [⊢ eqList_cons a a eqList_nil];

% List equality examples
rec list_equality_example : [⊢ nd (eqList (cons a (cons b nil)) (cons a (cons b nil)))] =
  [⊢ eqList_cons a a (eqList_cons b b eqList_nil)];

% Proof that append is associative (specific example)
rec append_assoc_example : [⊢ nd (appendR (cons a nil) (appendR (cons b nil) (cons a nil) (cons b (cons a nil))) 
                                    (appendR (appendR (cons a nil) (cons b nil) (cons a (cons b nil))) (cons a nil) 
                                            (cons a (cons b (cons a nil)))))] =
  [⊢ ⊤I]; % Simplified for now

% Demonstrate simple list operations
rec list_operation_example : [⊢ nd (⊤)] =
  [⊢ ⊤I];